template <typename T>
inline void foo(T var) {}

class Susake {};

Susake *A = nullptr;

int main(int argc, char *argv[]) {
  
  A = new Susake();
  delete A;
  
  return 0;
}

倾向于炫技，陶醉于对语言各种细节的深入探索，华丽化，复杂化
/***************************************
void

The (nonexistent) value of a void expression (an expression that has type void) shall not be used in any way, 
and implicit or explicit conversions (except to void) shall not be applied to such an expression. If an expression 
of any other type is evaluated as a void expression, its value or designator is discarded. (A void expression is 
evaluated for its side effects.)

void;
/***************************************
nullptr 

both (int*)0 and nullptr are valid template-arguments for a non-type template-parameter of type “pointer to int.”

【null pointer constant】

An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer 
constant.66) If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, 
is guaranteed to compare unequal to a pointer to any object or function

nullptr对应的一定是指针型变量，而null对应的有可能是指针型变量或者常量0

Types *val = nullptr;
/***************************************
auto

auto val = Types;//自动将val转化为对应的类型
/***************************************
bool true false char char16_t char32_t wchar_t int float double unsigned signed short long class new delete emum

break case continue default do else for goto if switch while namespace private protected public return sizeof struct

template typename union using typedef try catch throw this

这些都太简单了
/***************************************
const

const int val = 1;//将val定义成值为1的int型常量
/***************************************
extern

The external representations in a text file need not be identical to the internal representations, and are outside 
the scope of this International Standard.

main1.cpp
int a = 1;
main2.cpp
extern int a;
【translation unit】 

The text of the program is kept in units called source files in this International Standard. A source file together 
with all the headers (17.6.1.2) and source files included (16.2) via the preprocessing directive #include, less any 
source lines skipped by any of the conditional inclusion (16.1) preprocessing directives, is called a translation unit
/***************************************
inline 

A function declared with an inline function specifier is an inline function. Making a function an inline function 
suggests that calls to the function be as fast as possible.138)

inline void foo() { /*...*/ }
/***************************************
register

A declaration of an identifier for an object with storage-class specifier register suggests that access to the 
object be as fast as possible. The extent to which such suggestions are effective is implementation-defined.121)

register int val;
/***************************************
restrict const_cast dynamic_cast reinterpret_cast static_cast alignas alignof asm

IDE不一定支持或很少使用的
/***************************************
static

If the declaration of a file scope identifier for an object or a function contains the storageclass specifier static, 
the identifier has internal linkage.30)

static int val;
/***************************************
volatile

1.The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant.
2.Accessing a volatile object, modifying an object, modifying a file, or calling a function that does any of those 
operations are all side effects,12) which are changes in the state of the execution environment. Evaluation of an 
expression in general includes both value computations and initiation of side effects. Value computation for 
an lvalue expression includes determining the identity of the designated object.
3.Accesses to volatile objects are evaluated strictly according to the rules of the abstract machine.

volatile int val;
volatile所修饰的对象不会被abstract machine优化
/***************************************
constexpr

const可能会在编译期间被修改，这时应该使用constexpr
/***************************************
decltype

explicit

export

friend
/***************************************
mutable
如果一个结构被const 修饰，那么它将无法修改其成员变量的，但是如果这个成员变量是被mutable修饰的话，则可以修改
/***************************************
noexcept

operator

static_assert

thread_local

typeid

virtual
